#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#

#
# Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#

#
# Copyright (c) 2013, 2020 by Delphix. All rights reserved.
#

. $STF_SUITE/include/libtest.shlib
. $STF_SUITE/tests/functional/slog/slog.cfg

function setup
{
	log_must rm -rf $VDIR $VDIR2
	log_must mkdir -p $VDIR $VDIR2
	log_must truncate -s $MINVDEVSIZE $VDEV $SDEV $LDEV $VDEV2 $SDEV2 $LDEV2

	return 0
}

function cleanup
{
	poolexists $TESTPOOL && destroy_pool $TESTPOOL
	poolexists $TESTPOOL2 && destroy_pool $TESTPOOL2
	rm -rf $TESTDIR $VDIR $VDIR2
}

#
# Try zpool status/iostat for given pool
#
# $1 pool
#
function display_status
{
	typeset pool=$1

	typeset -i ret=0
	zpool status -xv $pool > /dev/null 2>&1
	ret=$?

	zpool iostat > /dev/null 2>&1
	((ret |= $?))

	typeset mntpnt=$(get_prop mountpoint $pool)
	dd if=/dev/urandom of=$mntpnt/testfile.$$ &
	typeset pid=$!

	zpool iostat -v 1 3 > /dev/null
	((ret |= $?))

	kill -9 $pid
	wait

	return $ret
}

#
# Verify the give slog device have correct type and status
#
# $1 pool name
# $2 device name
# $3 device status
# $4 device type
#
function verify_slog_device
{
	typeset pool=$1
	typeset device=$2
	typeset status=$3
	typeset type=$4

	if [[ -z $pool || -z $device || -z $status ]]; then
		log_fail "Usage: verify_slog_device <pool> <device> " \
			"<status> [type]"
	fi

	#
	# Get all the slog devices and status table like below
	#
	# mirror:/disks/d ONLINE mirror:/disks/e ONLINE stripe:/disks/f ONLINE
	#
	set -A dev_stat_tab $(zpool status -v $pool | nawk 'BEGIN {start=0} \
				/\tlogs/ {start=1}
				/\tmirror/ || /\tspares/ || /^$/ {start=0}
				(start==1) && /\t  (\/|[a-zA-Z])/ \
					{print "stripe:" $1 " " $2}
				(start==1) && /\t    (\/|[a-zA-Z])/ \
					{print "mirror:" $1 " " $2}
				# When hotspare is replacing
				(start==1) && /\t      (\/|[a-zA-Z])/ \
					{print "mirror:" $1 " " $2}'
			     )

	typeset -i i=0
	typeset find=0
	while (( i < ${#dev_stat_tab[@]} )); do
		typeset dev=${dev_stat_tab[$i]}
		typeset stat=${dev_stat_tab[((i+1))]}

		case $dev in
			stripe:$device)
				if [[ "$type" == 'mirror' ]]; then
					log_note "Unexpected type: mirror"
					return 1
				else
					if [[ $stat != $status ]]; then
						log_note "Status($stat) " \
							"!= Expected stat($status)"
						return 1
					fi
					return 0
				fi
				;;
			mirror:$device)
				if [[ -z "$type" || $type == 'stripe' ]]; then
					log_note "Unexpected type: stripe"
					return 1
				else
					if [[ $stat != $status ]]; then
						log_note "Status($stat) " \
							"!= Expected stat($status)"
						return 1
					fi
					return 0
				fi
				;;
		esac

		((i += 2))
	done

	log_note "Can not find device: $device"

	return 1
}

function get_embedded_slog_devices
{
	typeset pool=$1
	typeset devices
	typeset cmd

	# Note that the filter operator uses '>' because sdb does not
	# yet support '!='
	cmd="spa $pool | vdev | filter obj.vdev_log_mg > 0 | member vdev_path"

	devices=$(echo "$cmd" | sdb -k 2>/dev/null | \
	    sed -n 's/.*\"\(.*\)\"$/\1/p')

	echo $devices
}

function get_embedded_slog_count
{
	typeset pool=$1
	typeset count

	count=$(get_embedded_slog_devices $pool | wc -w)

	echo $count
}

# This test is a direct adaptation of the ziltest.sh
# script for the ZFS Test Suite.
function ziltest
{
	typeset pool=$1
	typeset dataset=$2
	typeset file_dev_dir=$3
	typeset mntpt=$(get_prop mountpoint $dataset)

	typeset tx_list="TX_CREATE TX_MKDIR TX_MKXATTR TX_SYMLINK TX_REMOVE \
	    TX_RMDIR TX_LINK TX_RENAME TX_WRITE TX_TRUNCATE TX_SETATTR"

	#
	# This dd command works around an issue where ZIL records aren't created
	# after freezing the pool unless a ZIL header already exists. Create a
	# file synchronously to force ZFS to write one out.
	#
	log_must dd if=/dev/zero of=$mntpt/sync \
	    conv=fdatasync,fsync bs=1 count=1

	#
	# 2. Freeze the test fs
	#
	log_must zpool freeze $pool

	#
	# 3. Run various user commands that create files, directories and ACLs
	#

	# TX_CREATE
	log_must touch $mntpt/a

	# TX_RENAME
	log_must mv $mntpt/a $mntpt/b

	# TX_SYMLINK
	log_must touch $mntpt/c
	log_must ln -s $mntpt/c $mntpt/d

	# TX_LINK
	log_must touch $mntpt/e
	log_must ln $mntpt/e $mntpt/f

	# TX_MKDIR
	log_must mkdir $mntpt/dir_to_delete

	# TX_RMDIR
	log_must rmdir $mntpt/dir_to_delete

	# Create a simple validation payload
	log_must mkdir -p $TESTDIR
	log_must dd if=/dev/urandom of=$mntpt/payload bs=1k count=8
	log_must eval "sha256sum -b $mntpt/payload >$TESTDIR/checksum"

	# TX_WRITE (small file with ordering)
	log_must mkfile 1k $mntpt/small_file
	log_must mkfile 512b $mntpt/small_file

	# TX_CREATE, TX_MKDIR, TX_REMOVE, TX_RMDIR
	log_must cp -R /usr/share/dict $mntpt
	log_must rm -rf $mntpt/dict

	# TX_SETATTR
	log_must touch $mntpt/setattr
	log_must chmod 567 $mntpt/setattr
	log_must chgrp root $mntpt/setattr
	log_must touch -cm -t 201311271200 $mntpt/setattr

	# TX_TRUNCATE (to zero)
	log_must mkfile 4k $mntpt/truncated_file
	log_must truncate -s 0 $mntpt/truncated_file

	# TX_WRITE (large file)
	log_must dd if=/dev/urandom of=$mntpt/large bs=128k count=64 oflag=sync

	# Write zeros, which compress to holes, in the middle of a file
	log_must dd if=/dev/urandom of=$mntpt/holes.1 bs=128k count=8
	log_must dd if=/dev/zero of=$mntpt/holes.1 bs=128k count=2

	log_must dd if=/dev/urandom of=$mntpt/holes.2 bs=128k count=8
	log_must dd if=/dev/zero of=$mntpt/holes.2 bs=128k count=2 seek=2

	log_must dd if=/dev/urandom of=$mntpt/holes.3 bs=128k count=8
	log_must dd if=/dev/zero of=$mntpt/holes.3 bs=128k count=2 \
	   seek=2 conv=notrunc

	# TX_MKXATTR
	log_must mkdir $mntpt/xattr.dir
	log_must touch $mntpt/xattr.file
	log_must set_xattr fileattr HelloWorld $mntpt/xattr.dir
	log_must set_xattr tmpattr HelloWorld $mntpt/xattr.dir
	log_must rm_xattr fileattr $mntpt/xattr.dir

	log_must set_xattr fileattr HelloWorld $mntpt/xattr.file
	log_must set_xattr tmpattr HelloWorld $mntpt/xattr.file
	log_must rm_xattr tmpattr $mntpt/xattr.file

	#
	# 4. Copy the test fs to temporary location (TESTDIR/copy)
	#
	log_must mkdir -p $TESTDIR/copy
	log_must cp -a $mntpt/* $TESTDIR/copy/

	#
	# 5. Unmount filesystem and export the pool
	#
	# At this stage the test fs is empty again and frozen, the intent log
	# contains a complete set of deltas to replay.
	#
	log_must zfs unmount $dataset

	log_note "Verify transactions to replay:"
	log_must zdb -iv $dataset

	# Verify that zdb observes records for each type of data recorded
	typeset tx_seen=$(zdb -iv $dataset | \
	    awk '{if(n == 1) print $0} /Total/ {n=1}')
	for i in $tx_list; do
		echo $tx_seen | grep -q $i || \
		    log_fail "zdb did not find record type $i"
	done

	log_must zpool export $pool

	#
	# 6. Remount the test fs <which replays the intent log>
	#
	# Import the pool to unfreeze it and claim log blocks.  It has to be
	# `zpool import -f` because we can't write a frozen pool's labels!
	#
	[[ -n $file_dev_dir ]] && file_dev_dir="-d $file_dev_dir"
	log_must zpool import -f $file_dev_dir $pool

	#
	# 7. Compare the test fs against the TESTDIR/copy
	#
	log_note "Verify current block usage:"
	log_must zdb -bcv $pool

	log_note "Verify copy of xattrs:"
	log_must ls_xattr /$TESTPOOL/$TESTFS/xattr.dir
	log_must ls_xattr /$TESTPOOL/$TESTFS/xattr.file

	log_note "Verify working set diff:"
	log_must diff -r $mntpt $TESTDIR/copy

	log_note "Verify file checksum:"
	log_must sha256sum -c $TESTDIR/checksum

	#
	# Cleaunup the data left in $TESTDIR
	#
	rm -rf $TESTDIR/*
}
